
<p>
    Errors can also be mapped to an object (meant to be the model) and its fields. This is helpful in scenarios
    you are handling more than one model within the current scope. You can store errors for each model and each 
    of its fields. 
</p>

<p>
    You can add errors mapped to model with the same <code>AddError</code> function used for other errors.
</p>

<csharp>
validator.AddError(model, "name", "Name is too long");
validator.AddError(model2, "age", "Person is too young");
</csharp>

<p>
    These errors can be fetched based on the models as follows:
</p>

<csharp>
IEnumerable&lt;KeyValuePair&lt;string, IEnumerable&lt;string>>> allErrorsOfModel = validator.GetErrors(model);
IEnumerable&lt;KeyValuePair&lt;string, IEnumerable&lt;string>>> allErrorsOfModel2 = validator[model2];

IEnumerable&lt;string> nameErrorsOfModel = validator.GetErrors(model, "name");
IEnumerable&lt;string> nameErrorsOfModel2 = validator.GetErrors(model2, "name");
</csharp>

<p>
    Model mappings can also use helper objects that can be generated by the model validator.
</p>

<csharp>
var helper = validator.GetHelper(model);
</csharp>

<p>
    This function gets a new helper that is mapped with the model. The usage of this usage would be the same as the
    helpers in the previous section.
</p>